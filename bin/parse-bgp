#!/usr/bin/env python3

# parse-bgp - convert "sh ip bgp" to ipv4-heatmap data
# Copyright (C) 2015-2020 Ryan Finnie
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

import argparse
import ipaddress
import json
import re
import sys
import time


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        "--quiet", "-q", dest="quiet", action="store_true", help="quiet mode"
    )
    parser.add_argument("--config", "-c", type=str, help="configuration json")

    args = parser.parse_args()

    return args


r_v46cidr = re.compile(r"^\*. ([0-9a-f:\.]+)(\/([0-9]+))?")

IGNORE = []
V6_START = "2000::"
V6_LENGTH = 4


def get_match(line):
    match = re.match(r_v46cidr, line)
    if match is None:
        return

    (ip, _, cidr) = match.groups()
    ip = ipaddress.ip_address(ip)

    # Some "sh ip bgp" output will only show CIDR notation for classless
    # announcements.  We need to figure out the netmask for classful
    # announcements ourselves.
    if cidr is None:
        if ip.version == 6:
            return
        if ip in ipaddress.IPv4Network("224.0.0.0/3"):
            return
        elif ip in ipaddress.IPv4Network("192.0.0.0/3"):
            cidr = 24
        elif ip in ipaddress.IPv4Network("128.0.0.0/2"):
            cidr = 16
        else:
            cidr = 8

    net = ipaddress.ip_network("{}/{}".format(ip, cidr))

    if (net.version == 6) and (not net.subnet_of(V6_SUPERNET)):
        return
    return net


args = parse_args()
is_tty = sys.stderr.isatty()

if args.config:
    with open(args.config) as f:
        json_config = json.load(f)
    if "v6_start" in json_config:
        V6_START = json_config["v6_start"]
    if "v6_length" in json_config:
        V6_LENGTH = json_config["v6_length"]
    if "ignore" in json_config:
        IGNORE = json_config["ignore"]

last_status_time = time.time()
cidr_24_dict = {}
routes_loaded = 0
mode_ipv6 = None
V6_SUPERNET = ipaddress.IPv6Network("{}/{}".format(V6_START, V6_LENGTH))

for line in sys.stdin:
    # Look for announcements
    net = get_match(line)
    if net is None:
        continue

    cidr = net.prefixlen
    is_ipv6 = net.version == 6
    # 0.0.0.0/0 and ::/0 aren't too usefuf
    if cidr == 0:
        continue

    # Check configured ignores
    if net.compressed in IGNORE:
        continue

    routes_loaded += 1
    if mode_ipv6 is None:
        if is_ipv6:
            if not args.quiet:
                print("IPv6 mode.", file=sys.stderr)
            mode_ipv6 = True
        else:
            if not args.quiet:
                print("IPv4 mode.", file=sys.stderr)
            mode_ipv6 = False
    if is_ipv6:
        adj_cidr = cidr - V6_LENGTH
    else:
        adj_cidr = cidr
    if adj_cidr < 0:
        continue
    if adj_cidr > 32:
        adj_cidr = 32
    cidr_offset = 32 - 8
    int_32 = int(net.network_address)
    if is_ipv6:
        int_32 = (
            (int(net.network_address) - int(V6_SUPERNET.network_address))
            & ((2 ** (128 - V6_LENGTH)) - 1)
        ) >> (128 - 32 - V6_LENGTH)
    int_24_masked = int_32 >> 8

    # If the network is smaller than the masked 24-bit destination, all
    # we need to do is put it in the destination entry.  But if it's
    # larger, then we need to loop over successive entries.
    if adj_cidr > cidr_offset:
        if (int_24_masked not in cidr_24_dict) or (cidr > cidr_24_dict[int_24_masked]):
            cidr_24_dict[int_24_masked] = cidr
    else:
        for i in range(2 ** (cidr_offset - adj_cidr)):
            int_24_masked_2 = int_24_masked + i
            if (int_24_masked_2 not in cidr_24_dict) or (
                cidr > cidr_24_dict[int_24_masked_2]
            ):
                cidr_24_dict[int_24_masked_2] = cidr

    now = time.time()
    if (not args.quiet) and is_tty and (now > (last_status_time + 1)):
        sys.stderr.write("\r\x1b[KLoading: {} ({} routes)".format(net, routes_loaded))
        sys.stderr.flush()
        last_status_time = now

total_entries = len(cidr_24_dict)
if not args.quiet:
    if is_tty:
        sys.stderr.write("\r\x1b[K")
    print(
        "%d routes loaded, %d entries." % (routes_loaded, total_entries),
        file=sys.stderr,
    )

last_status_time = time.time()
entries_printed = 0

for int_24_masked in sorted(cidr_24_dict.keys()):
    cidr = cidr_24_dict[int_24_masked]
    adjcidr = cidr

    # Currently no announcements are outside these bounds (/12 - /64 for
    # IPv6, /8 - /32 for IPv4), but if they ever do, we want to pretend
    # they have these bounds.
    if mode_ipv6:
        cidr_low = 8 + V6_LENGTH
        cidr_high = cidr_low + 52
    else:
        cidr_low = 8
        cidr_high = 32
    if cidr > cidr_high:
        adjcidr = cidr_high
    elif cidr < cidr_low:
        adjcidr = cidr_low

    # Since this output is for feeding into ipv4-heatmap (which by its
    # name is IPv4-only), we pretend the entire masked 24-bit range is
    # an IPv4 network, even if it's IPv6.
    ip = int_24_masked << 8
    ip_24 = ipaddress.IPv4Address(ip).compressed

    # Range from cidr_low to cidr_high, mapped to color indexes 0-255
    color_idx = int((adjcidr - cidr_low) / float(cidr_high - cidr_low) * 255.0)

    print("%s %d" % (ip_24, color_idx))

    entries_printed += 1
    now = time.time()
    if (not args.quiet) and is_tty and (now > (last_status_time + 1)):
        sys.stderr.write(
            "\r\x1b[KPrinting: {} ({:.0%})".format(
                ip_24, (entries_printed / total_entries)
            )
        )
        sys.stderr.flush()
        last_status_time = now

if not args.quiet:
    if is_tty:
        sys.stderr.write("\r\x1b[K")
    print("%d entries printed." % entries_printed, file=sys.stderr)
